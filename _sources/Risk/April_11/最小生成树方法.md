# 最小生成树

## 5. 最小生成树算法

### 5.1 Kruskal算法

假设给定的连通图G是完全的，也就是说，每一对顶点都由一条边连接。

构造A：在G中还没有被选中的边中，选择一条最短的边，它不会与已经被选中的边形成任何循环。显然最终选择的边的集合必须形成G的生成树，事实上它形成了最短的生成树。

构造B：设V是G的任意但固定(非空)的顶点子集，然后尽可能多地执行以下步骤:在G中还没有被选择的，但连接到V的一个顶点或已经选择的边的边中，选择一条最短的边，它不会与已经选择的边形成任何循环。显然最终选择的边的集合形成了G的生成树，实际上它形成了最短的生成树。如果V是G的所有顶点的集合，则构造B可化为构造A。

构造A’：这种方法在某种意义上与a是对偶的，尽可能多地执行以下步骤:在尚未选择的边中，选择除去后不会断开它们的最长边。很明显，最终没有选择的边的集合形成了G的生成树，实际上它形成了最短的生成树。在我看来，构造B是否在总体上有一个类似于这个的双重结构是不清楚的。

证明见原文。

参考文献：

Kruskal，J.B.On the Shortest Spanning Subtre of a Graph and the Traveling Salesman Problem[J].Proccedings of the American Mathematical Society，1956，7(1):48—50.

### 5.2算法实现



```python
# Python program for Kruskal's algorithm to find
# Minimum Spanning Tree of a given connected,
# undirected and weighted graph
  
# This code is contributed by Neelam Yadav
from collections import defaultdict
 
# Class to represent a graph
 
class Graph():
 
    def __init__(self, vertices):
        self.V = vertices  # No. of vertices
        self.graph = []  # default dictionary
        # to store graph
 
    # function to add an edge to graph
    def addEdge(self, u, v, w):
        self.graph.append([u, v, w])
 
    # A utility function to find set of an element i
    # (uses path compression technique)
    def find(self, parent, i):
        if parent[i] == i:
            return i
        return self.find(parent, parent[i])
 
    # A function that does union of two sets of x and y
    # (uses union by rank)
    def union(self, parent, rank, x, y):
        xroot = self.find(parent, x)
        yroot = self.find(parent, y)
 
        # Attach smaller rank tree under root of
        # high rank tree (Union by Rank)
        if rank[xroot] < rank[yroot]:
            parent[xroot] = yroot
        elif rank[xroot] > rank[yroot]:
            parent[yroot] = xroot
 
        # If ranks are same, then make one as root
        # and increment its rank by one
        else:
            parent[yroot] = xroot
            rank[xroot] += 1
 
    # The main function to construct MST using Kruskal's
        # algorithm
    def KruskalMST(self):
 
        result = []  # This will store the resultant MST
         
        # An index variable, used for sorted edges
        i = 0
         
        # An index variable, used for result[]
        e = 0
 
        # Step 1:  Sort all the edges in
        # non-decreasing order of their
        # weight.  If we are not allowed to change the
        # given graph, we can create a copy of graph
        self.graph = sorted(self.graph,
                            key=lambda item: item[2])
 
        parent = []
        rank = []
 
        # Create V subsets with single elements
        for node in range(self.V):
            parent.append(node)
            rank.append(0)
 
        # Number of edges to be taken is equal to V-1
        while e < self.V - 1:
 
            # Step 2: Pick the smallest edge and increment
            # the index for next iteration
            u, v, w = self.graph[i]
            i = i + 1
            x = self.find(parent, u)
            y = self.find(parent, v)
 
            # If including this edge does't
            #  cause cycle, include it in result
            #  and increment the indexof result
            # for next edge
            if x != y:
                e = e + 1
                result.append([u, v, w])
                self.union(parent, rank, x, y)
            # Else discard the edge
 
        minimumCost = 0
        print ("Edges in the constructed MST")
        for u, v, weight in result:
            minimumCost += weight
            print("%d -- %d == %d" % (u, v, weight))
        print("Minimum Spanning Tree" , minimumCost)

```


```python
# Driver code
g = Graph(4)
g.addEdge(0, 1, 10)
g.addEdge(0, 2, 6)
g.addEdge(0, 3, 5)
g.addEdge(1, 3, 15)
g.addEdge(2, 3, 4)
 
# Function call
g.KruskalMST()
```

    Edges in the constructed MST
    2 -- 3 == 4
    0 -- 3 == 5
    0 -- 1 == 10
    Minimum Spanning Tree 19



## 6. 最小生成树的拓扑指标

1. 归一化树长（NTL）

   NTL定义为最小生成树网络的平均距离，代表节点在网络中的发散程度。
   
   $$
   NTL(t)=\frac{1}{N-1}\sum_{i,j\in T}d_{ij}
   $$

2. 平均相似度（MSM）

   $$
   MSM = \frac{2}{N(N-1)}\sum_{i=1}^{N-1}\sum^{N}_{j=i+1}D_{ij}
   $$
   
   $D$表示$N\times N$的相似矩阵

3. 特征路径长度（CPL）

   任意两个节点i与j的平均路由个数，用来度量密集程度。
   
   $$
   CPL = \frac{2}{N(N-1)}\sum_{i,j,i\neq j}l_{ij}
   $$
   
   $l_{ij}$表示节点i和j的最短路径的边数。

4. 平均占有层（MOL）

   $MOL(v_e)=\frac{1}{N}\sum_{i=1}^{N}lev(v_i)$

   $v_i$表示节点，$lev(v_i)$表示两者所在层数的差。

5. 非叶子节点数（NLM）

   度量MST网络的松散程度，叶子节点是树中没有子节点的节点，即度数为0的节点，而非叶子节点为树中度大于0的节点。

参考文献

- 张金林,孙凌芸.复杂网络理论下跨市场金融风险传染机制与路径研究[J].中南财经政法大学学报,2020(02):110-121.DOI:10.19639/j.cnki.issn1003-5230.2020.0018.




